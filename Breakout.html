
<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Breakout Iteration 4.01 (Power Ups)</title>
    <script src="phaser.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>

<script type="text/javascript">

    var config = {
        type: Phaser.AUTO,
        width: 600,
        height: 800,
        physics: {
            default: 'arcade',
            arcade: {
                debug: false
            }
        },
        scene: {
            preload: preload,
            create: create,
            update: update
        }
    };

    var game = new Phaser.Game(config);

    var life = 3;
    var numbreaks = 0;
    var winning = false;
    var losing = false;
    var eject = false;
    var start = false;
    var paddle_speed = 300;
    var paddle2_speed = 300;
    var initial_ball_speed_vector = (100, 200);
    var max_ball_speed = 200;
    var cur_max_ball_speed = max_ball_speed;
    var game_offset = { x: 0, y: 0 };
    var first_brick_offset = { x: game_offset.x + 75, y: game_offset.y + 350 };
    var brick_steps = { x: 50, y: 25 };
    var brick_scales = { x: .8, y: .3 };
    var paddle_initial_offset = { x: game_offset.x + 300, y: game_offset.y + 700 };
    var paddle_scales = { x: .5, y: .25 };
    var paddle2_initial_offset = { x: game_offset.x + 300, y: game_offset.y + 100 };
    var paddle2_scales = { x: .5, y: .25 };
    var ball_initial_offset = {x: game_offset.x + 300, y: game_offset.y + 685 };
    var ball_scales = { x: .5, y: .5 };
    var trap_initial_offset = { x: 0, y: 800 };
    var trap_scale = {x : 2.5 , y : 1 };
    var trap_top_initial_offset = { x: 0, y: 0 };
    var trap_top_scale = {x : 2.5 , y : 1 };
    var power_speed = 200;
    var power_scale = { x: 1, y: 1 };
    var power_chance_out_of_100 = 10;
    var num_balls = 0;

    function reset_ball()
    {
        ball.enableBody(true,
                        ball_initial_offset.x,
                        ball_initial_offset.y,
                        true,
                        true);
        num_balls = 1;
    }

    function spawn_two_balls(that)
    {
        var newBall1 = that.physics.add.sprite(paddle.x - paddle.displayWidth/3,
                                                       ball_initial_offset.y,'ball');
        newBall1.setCollideWorldBounds(true);
        newBall1.setVelocity(-200,-200); // Up and to the left
        newBall1.setBounce(1);
        newBall1.setMaxVelocity(cur_max_ball_speed);
        newBall1.scaleX = ball_scales.x;
        newBall1.scaleY = ball_scales.y;
        num_balls++;
        that.physics.add.collider(newBall1, paddle, ball_paddle_collision, null, that);
        that.physics.add.collider(newBall1, paddle2, ball_paddle_collision, null, that);
        that.physics.add.collider(newBall1, bricks, ball_brick_collision, null, that);
        that.physics.add.collider(newBall1, trap, ball_trap_collision, null, that);
        that.physics.add.collider(newBall1, trap_top, ball_trap_collision, null, that);

        var newBall2 = that.physics.add.sprite(paddle.x + paddle.displayWidth/3,
                                                ball_initial_offset.y,'ball');
        newBall2.setCollideWorldBounds(true);
        newBall2.setVelocity(200,-200); // Up and to the right
        newBall2.setBounce(1);
        newBall2.setMaxVelocity(cur_max_ball_speed);
        newBall2.scaleX = ball_scales.x;
        newBall2.scaleY = ball_scales.y;
        num_balls++;
        that.physics.add.collider(newBall2, paddle, ball_paddle_collision, null, that);
        that.physics.add.collider(newBall2, paddle2, ball_paddle_collision, null, that);
        that.physics.add.collider(newBall2, bricks, ball_brick_collision, null, that);
        that.physics.add.collider(newBall2, trap, ball_trap_collision, null, that);
        that.physics.add.collider(newBall2, trap_top, ball_trap_collision, null, that);
    }

    // Function for creating the grid of bricks
    function create_bricks(rows, cols, that)
    {
        var bricks = that.physics.add.staticGroup();

        for(i = 0; i < cols; i++)
        {
            for(j = 0; j < rows; j++)
            {
                var newBrick = bricks.create(first_brick_offset.x + i*brick_steps.x,
                              first_brick_offset.y + j*brick_steps.y,
                              'brick');
                newBrick.scaleX = brick_scales.x;
                newBrick.scaleY = brick_scales.y;
                numbreaks++;
            }
        }
        return bricks;
    }

    // Callback function for when the ball hits a brick
    function ball_brick_collision(ball, brick)
    {
        if(Math.floor(Math.random() * 100) < power_chance_out_of_100)
        {
            var newpower = this.physics.add.sprite(brick.body.x, brick.body.y, 'power');
            newpower.setImmovable(true); // Don't move when the ball hits the paddle
            newpower.setVelocityY(power_speed);
            this.physics.add.collider(paddle, newpower, paddle_power_collision, null, this);
        }

        brick.disableBody(true,true);
        numbreaks--;
        // TODO: Tally score or detect when the player wins or something like that
        if(numbreaks == 0)
        {
          winning = true;
          winloseText.setText('You win!!!');
          ball.setVelocity(0,0);
          ball.body.x = ball_initial_offset.x-10;
          ball.body.y = ball_initial_offset.y-10;
          paddle.x = paddle_initial_offset.x;
          paddle.y = paddle_initial_offset.y;
          paddle2.x = paddle2_initial_offset.x;
          paddle2.y = paddle2_initial_offset.y;
        }
    }

    function preload ()
    {
        // Change these once we have the real assets
        this.load.image('paddle', 'assets/paddle_temp.png');
        this.load.image('brick', 'assets/brick_temp.png');
        this.load.image('ball', 'assets/ball_temp.png');
        this.load.image('trap','assets/trap.png');
        this.load.image('power','assets/bricks01.png');
        this.load.image('background','assets/background.png');
    }

    function ball_paddle_collision(ball, paddle)
    {
        //set velocity based on the postion collision
        //ball.setVelocityX(600 * ((ball.body.x - paddle.x) / paddle.displayWidth))

        //set velocity based on the speed of the paddle
        ball.setVelocityX(ball.body.velocity.x + paddle.body.velocity.x);

        //if(ball.x < paddle.x - paddle.displayWidth/6)
        //{
        //    // The ball is hitting the left third of the paddle
        //    if(ball.body.velocity.x >= 0)
        //    {
        //        // The ball is moving to the right
        //        // So reverse the ball's x velocity, making it move to the left
        //        ball.setVelocityX(-ball.body.velocity.x);
        //    }
        //}
        //else if(ball.x > paddle.x + paddle.displayWidth/6)
        //{
        //    // The ball is hitting the right third of the paddle
        //    if(ball.body.velocity.x <= 0)
        //    {
        //        // The ball is moving to the left
        //        // So reverse the ball's x velocity, making it move to the right
        //        ball.setVelocityX(-ball.body.velocity.x);
        //    }
        //}
        //else
        //{
        //    // The ball is hitting the center third of the paddle
        //    // So just make the ball bounce, keeping its direction
        //}
    }

    function ball_trap_collision(ball, trap)
    {
        ball.disableBody(true,true);
        num_balls--;

        if(num_balls === 0)
        {
            if (life === 1){
                losing = true;
                winloseText.setText('You lose!!');
                ball.setVelocity(0,0);
                ball.body.x = ball_initial_offset.x-10;
                ball.body.y = ball_initial_offset.y-10;
                paddle.x = paddle_initial_offset.x;
                paddle.y = paddle_initial_offset.y;
                paddle2.x = paddle2_initial_offset.x;
                paddle2.y = paddle2_initial_offset.y;
                //Game.pause();
                lifeText.setText('life: ' + 0);
            }

            else
            {
                life--;
                start = false;
                eject = false;
                ball.setVelocity(0,0);

                paddle.x = paddle_initial_offset.x;
                paddle.y = paddle_initial_offset.y;
                paddle2.x = paddle2_initial_offset.x;
                paddle2.y = paddle2_initial_offset.y;

                reset_ball();
                //ball.x = ball_initial_offset.x;
                //ball.y = ball_initial_offset.y;
                //ball.scaleX = ball_scales.x;
                //ball.scaleY = ball_scales.y;

                lifeText.setText('life: ' + life);

            }
        }
    }

    function paddle_power_collision(paddle, power)
    {
        //I want to use a switch case to implement all the buffs, but I think we can just generate a random buff for this update.
        power.disableBody(true, true);

        switch(Math.floor(Math.random()*4))
        {
            case 0: // triple ball
                spawn_two_balls(this);
                break;
            case 1: // slower ball

                break;
            case 2: // shorter paddle

                break;
            case 3: // regenerate bricks

                break;
        }
    }

    function create ()
    {
        trap = this.physics.add.sprite(trap_initial_offset.x, trap_initial_offset.y, 'trap');
        trap.setCollideWorldBounds(true);
        trap.setImmovable(true);
        trap.scaleX = trap_scale.x;
        trap.scaleY = trap_scale.y;

        trap_top = this.physics.add.sprite(trap_top_initial_offset.x, trap_top_initial_offset.y, 'trap');
        trap_top.setCollideWorldBounds(true);
        trap_top.setImmovable(true);
        trap_top.scaleX = trap_top_scale.x;
        trap_top.scaleY = trap_top_scale.y;

        background = this.physics.add.sprite(0, 0, 'background');
        background.setOrigin(0, 0);
        background.setScale(1.36, 1.45);

        //power = this.physics.add.sprite(0, 0, 'power');

        bricks = create_bricks(4,10,this);

        paddle = this.physics.add.sprite(paddle_initial_offset.x,paddle_initial_offset.y,'paddle');
        paddle.setCollideWorldBounds(true); // Don't allow movement outside the play area
        paddle.setImmovable(true); // Don't move when the ball hits the paddle
        paddle.scaleX = paddle_scales.x;
        paddle.scaleY = paddle_scales.y;

        paddle2 = this.physics.add.sprite(paddle2_initial_offset.x,paddle2_initial_offset.y,'paddle');
        paddle2.setCollideWorldBounds(true); // Don't allow movement outside the play area
        paddle2.setImmovable(true); // Don't move when the ball hits the paddle
        paddle2.scaleX = paddle2_scales.x;
        paddle2.scaleY = paddle2_scales.y;

        ball = this.physics.add.sprite(ball_initial_offset.x,ball_initial_offset.y,'ball');
        ball.setCollideWorldBounds(true); // Make the ball bounce off the play area
        ball.setVelocity(0,0);
        ball.setBounce(1); // Don't lose speed when bouncing
        ball.setMaxVelocity(max_ball_speed); // Never exceed max_ball_speed
        ball.scaleX = ball_scales.x;
        ball.scaleY = ball_scales.y;
        num_balls++;

        lifeText = this.add.text(16, 16, 'life: ' + life, { fontSize: '32px', fill: '#fff' });
        winloseText = this.add.text(230, 200, '', { fontSize: '60px', fill: '#fff' });

        this.physics.add.collider(ball, paddle, ball_paddle_collision, null, this);
        this.physics.add.collider(ball, paddle2, ball_paddle_collision, null, this);
        this.physics.add.collider(ball, bricks, ball_brick_collision, null, this);
        this.physics.add.collider(ball, trap, ball_trap_collision, null, this);
        this.physics.add.collider(ball, trap_top, ball_trap_collision, null, this);
        //this.physics.add.collider(paddle, power, paddle_power_collision, null, this);

        // TODO: Add a collider on the bottom of the screen that makes the player lose a life

        cursors = this.input.keyboard.createCursorKeys();

    }

    function update ()
    {
        // Handle keyboard controls for moving the paddle
        if(cursors.left.isDown)
        {
            paddle.setVelocityX(-paddle_speed);
            paddle2.setVelocityX(-paddle2_speed);
        }
        else if (cursors.right.isDown)
        {
            paddle.setVelocityX(paddle_speed);
            paddle2.setVelocityX(paddle2_speed);
        }
        else
        {
            paddle.setVelocityX(0);
            paddle2.setVelocityX(0);
        }

        if (cursors.space.isDown)
          if(start == false)
            eject = true;

        if (eject) {
          ball.setVelocity(200,200);
          eject = false;
          start = true
        }
        if(!start) {
          ball.x = paddle.x;
        }

        // TODO: If we want the ball to speed up after certain conditions,
        // TODO: check those conditions and update max_ball_speed and somehow
        // TODO: increase the ball's current speed

    }


</script>

</body>
</html>
