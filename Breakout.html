

<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Breakout Iteration 6 (Snowstorm and Portals)</title>
    <script src="phaser.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>

    <script type="text/javascript">

        var config = {
            type: Phaser.AUTO,
            width: 600,
            height: 800,
            physics: {
                default: 'arcade',
                arcade: {
                    debug: false
                }
            },
            scene: {
                preload: preload,
                create: create,
                update: update
            }
        };

        var game = new Phaser.Game(config);

        var life = 3;
        var numbreaks = 0;
        var winning = false;
        var losing = false;
        var eject = false;
        var start = false;
        var portaled = false;
        var paddle_speed = 300;
        var paddle2_speed = 300;
        var initial_ball_speed_vector = (100, 200);
        var max_ball_speed = 250;
        var cur_max_ball_speed = max_ball_speed;
        var min_ball_y_speed_factor = 1.0/2.0;
        var max_ball_x_speed_factor = Math.sqrt(3)*0.5
        var game_offset = { x: 0, y: 0 };
        var first_brick_offset = { x: game_offset.x + 95, y: game_offset.y + 350 };
        var brick_steps = { x: 46, y: 25 };
        var brick_scales = { x: .75, y: .5 };
        var brick_fade_time = 500;
        var ice_brick_scales = {x: brick_scales.x, y: brick_scales.y};
        var ice_brick_offset = {x: 2, y: 17};
        var paddle_initial_offset = { x: game_offset.x + 300, y: game_offset.y + 720 };
        var paddle_scales = { x: 1, y: 1 };
        var paddle2_initial_offset = { x: game_offset.x + 300, y: game_offset.y + 80 };
        var paddle2_scales = { x: 1, y: 1 };
        var ball_initial_offset = { x: game_offset.x + 300, y: game_offset.y + 695 };
        var ball_scales = { x: 1, y: 1 };
        //var ball_collider_size = {x:500, y:500};
        //var ball_collider_offset = {x:260, y:250};
        var brick_collider_size = {x: 45, y: 20};
        var brick_collider_offset = {x: 38, y: 50 };
        var trap_initial_offset = { x: 0, y: 800 };
        var trap_scale = { x: 2.5, y: 1 };
        var trap_top_initial_offset = { x: 0, y: 0 };
        var trap_top_scale = { x: 2.5, y: 1 };
        var portal1_initial_offset = { x: 300, y: 275 };
        var portal2_initial_offset = { x: 300, y: 515 };
        //var portal1_initial_offset = { x: 95, y: 275 };
        //var portal2_initial_offset = { x: 95, y: 515 };
        //var portal3_initial_offset = { x: 505, y: 275 };
        //var portal4_initial_offset = { x: 505, y: 515 };
        var portal_scales = { x: 0.8, y: 0.8 };
        var power_speed = 200;
        var power_scales = { x: 1.2, y: 1 };
        var power_chance_out_of_100 = 25;
        var max_slow_down_duration_in_ms = 10000; // 10 seconds
        var ball_speed_slow_factor = 1.0 / 2.0;
        var slow_down_timers = [];
        var balls = [];
        var snowstorm_start_tween_duration = 1000;
        var snowstorm_end_tween_duration = 500;
        var snowstorm_storm_duration = 10000;
        var cur_snowstorm_duration = 0;
        var snow_ms_per_frame = 200/3.0; // 15 frames per second
        var snowstorm_ms_per_frame = 200/9.0; // 45 frames per second
        var snowstorm_ball_accelerations = {x:100, y:0};
        var non_snowstorm_ball_accelerations = {x:0, y:0};
        var cur_ball_accelerations = {x:non_snowstorm_ball_accelerations.x, 
                                      y:non_snowstorm_ball_accelerations.y};
        var cur_snowstorm_direction = 'none';

        function reset_ball() {
            ball.enableBody(true,
                ball_initial_offset.x,
                ball_initial_offset.y,
                true,
                true);
            balls.push(ball);
            // TODO: Clear all the slow downs and other power ups
        }

        function reset_paddle() {
            paddle.setScale(paddle_scales.x, paddle_scales.y);
            paddle2.setScale(paddle2_scales.x, paddle2_scales.y);
        }
        function reset_portal() {
            portaled = false;
        }
        function reset_loseinglife() {
            losinglife.visible = false;
        }
        function ball_icewallleft_collision() {
            this.ball_bounce.play();
        }
        function ball_icewallright_collision() {
            this.ball_bounce.play();
        }


        function spawn_two_balls(that) {
            var newBall1 = that.physics.add.sprite(paddle.x - paddle.displayWidth / 3,
                ball_initial_offset.y, 'ball');
            newBall1.setCollideWorldBounds(true);
            newBall1.setVelocity(-200, -200); // Up and to the left
            newBall1.setBounce(1);
            newBall1.body.setMaxSpeed(cur_max_ball_speed);
            newBall1.scaleX = ball_scales.x;
            newBall1.scaleY = ball_scales.y;
            //newBall1.setSize(ball_collider_size.x,ball_collider_size.y);
            //newBall1.setOffset(ball_collider_offset.x, ball_collider_offset.y);
            balls.push(newBall1);
            newBall1.body.acceleration.x = cur_ball_accelerations.x;
            newBall1.body.acceleration.y = cur_ball_accelerations.y;
            that.physics.add.collider(newBall1, paddle, ball_paddle_collision, null, that);
            that.physics.add.collider(newBall1, paddle2, ball_paddle_collision, null, that);
            that.physics.add.collider(newBall1, bricks, ball_brick_collision, null, that);
            that.physics.add.collider(newBall1, trap, ball_trap_collision, null, that);
            that.physics.add.collider(newBall1, trap_top, ball_trap_collision, null, that);
            that.physics.add.collider(newBall1, portal1, ball_portal_collision, null, that);
            that.physics.add.collider(newBall1, portal2, ball_portal_collision, null, that);
            that.physics.add.collider(newBall1, icewallleft, ball_icewallleft_collision, null, that);
            that.physics.add.collider(newBall1, icewallright, ball_icewallright_collision, null, that);

            //that.physics.add.collider(newBall1, portal3, ball_portal_collision, null, that);
            //that.physics.add.collider(newBall1, portal4, ball_portal_collision, null, that);


            var newBall2 = that.physics.add.sprite(paddle.x + paddle.displayWidth / 3,
                ball_initial_offset.y, 'ball');
            newBall2.setCollideWorldBounds(true);
            newBall2.setVelocity(200, -200); // Up and to the right
            newBall2.setBounce(1);
            newBall2.body.setMaxSpeed(cur_max_ball_speed);
            newBall2.scaleX = ball_scales.x;
            newBall2.scaleY = ball_scales.y;
            //newBall2.setSize(ball_collider_size.x,ball_collider_size.y);
            //newBall2.setOffset(ball_collider_offset.x, ball_collider_offset.y);
            balls.push(newBall2);
            newBall2.body.acceleration.x = cur_ball_accelerations.x;
            newBall2.body.acceleration.y = cur_ball_accelerations.y;
            that.physics.add.collider(newBall2, paddle, ball_paddle_collision, null, that);
            that.physics.add.collider(newBall2, paddle2, ball_paddle_collision, null, that);
            that.physics.add.collider(newBall2, bricks, ball_brick_collision, null, that);
            that.physics.add.collider(newBall2, trap, ball_trap_collision, null, that);
            that.physics.add.collider(newBall2, trap_top, ball_trap_collision, null, that);
            that.physics.add.collider(newBall2, portal1, ball_portal_collision, null, that);
            that.physics.add.collider(newBall2, portal2, ball_portal_collision, null, that);
            that.physics.add.collider(newBall2, icewallleft, ball_icewallleft_collision, null, that);
            that.physics.add.collider(newBall2, icewallright, ball_icewallright_collision, null, that);

            //that.physics.add.collider(newBall2, portal3, ball_portal_collision, null, that);
            //that.physics.add.collider(newBall2, portal4, ball_portal_collision, null, that);
        }

        function tween_from_snowstorm(startDirection, that)
        {
            if(startDirection === 'none' || startDirection != cur_snowstorm_direction)
            {
                return; // Do nothing if there is no storm active or if the other storm is active
            }

            cur_snowstorm_direction = 'none';
            cur_snowstorm_duration = 0;

            // Tween the framerate of the storm down to nonsnowstorm levels
            that.tweens.add({
                targets: snowField.anims,
                duration: snowstorm_end_tween_duration,
                msPerFrame: {start: snowstorm_ms_per_frame, to: snow_ms_per_frame},
            });


            // Tween the acceleration of the balls
            that.tweens.add({
                targets: cur_ball_accelerations,
                duration: snowstorm_end_tween_duration,
                x: {start: cur_ball_accelerations.x, to: non_snowstorm_ball_accelerations.x},
                y: {start: cur_ball_accelerations.y, to: non_snowstorm_ball_accelerations.y},
                onUpdate: function () {
                    balls.forEach((val) => {
                        val.body.acceleration.x = cur_ball_accelerations.x;
                        val.body.acceleration.y = cur_ball_accelerations.y;
                    });
                }
            });

            if(startDirection === 'left')
            {
                // Tween the direction of the snow back to normal
                that.tweens.add({
                    targets: snowField,
                    duration: snowstorm_end_tween_duration,
                    angle: {start: -140, to: -180}
                });
            }
            else
            {
                // Tween the direction of the snow back to normal
                that.tweens.add({
                    targets: snowField,
                    duration: snowstorm_end_tween_duration,
                    angle: {start: 140, to: 180}
                });
            }


        }

        function tween_to_snowstorm(direction, that)
        {
            if(direction === 'none' || direction === cur_snowstorm_direction)
            {
                return; // Nothing to do if a direction wasn't specified or is already going
            }

            cur_snowstorm_direction = direction;
            cur_snowstorm_duration += snowstorm_storm_duration + snowstorm_start_tween_duration;

            // Tween the framerate of the storm up to snowstorm levels
            that.tweens.add({
                targets: snowField.anims,
                duration: snowstorm_start_tween_duration,
                msPerFrame: {start: snow_ms_per_frame, to: snowstorm_ms_per_frame},
            });

            if(direction === 'left')
            {
                // Tween the direction of the storm to the left
                that.tweens.add({
                    targets: snowField,
                    duration: snowstorm_start_tween_duration,
                    angle: {start: -180, to: -140}
                });

                // Tween the acceleration of the balls
                that.tweens.add({
                    targets:cur_ball_accelerations,
                    duration: snowstorm_start_tween_duration,
                    x: {start: non_snowstorm_ball_accelerations.x, to: -snowstorm_ball_accelerations.x},
                    y: {start: non_snowstorm_ball_accelerations.y, to: snowstorm_ball_accelerations.y},
                    onUpdate: function () {
                        balls.forEach((val) => {
                            val.body.acceleration.x = cur_ball_accelerations.x;
                            val.body.acceleration.y = cur_ball_accelerations.y;
                        });
                    }
                });
            }
            else
            {
                // Tween the direction of the storm to the right
                that.tweens.add({
                    targets: snowField,
                    duration: snowstorm_start_tween_duration,
                    angle: {start: 179, to: 140}
                });

                // Tween the acceleration of the balls
                that.tweens.add({
                    targets:cur_ball_accelerations,
                    duration: snowstorm_start_tween_duration,
                    x: {start: non_snowstorm_ball_accelerations.x, to: snowstorm_ball_accelerations.x},
                    y: {start: non_snowstorm_ball_accelerations.y, to: snowstorm_ball_accelerations.y},
                    onUpdate: function () {
                        balls.forEach((val) => {
                            val.body.acceleration.x = cur_ball_accelerations.x;
                            val.body.acceleration.y = cur_ball_accelerations.y;
                        });
                    }
                });
            }
        }

        // Function for creating the grid of bricks
        function create_bricks(rows, cols, that) {
            var bricks = that.physics.add.staticGroup();

            for (i = 0; i < cols; i++) {
                for (j = 0; j < rows; j++) {
                    var newBrick = bricks.create(first_brick_offset.x + i * brick_steps.x,
                        first_brick_offset.y + j * brick_steps.y,
                        'brick');
                    newBrick.setSize(brick_collider_size.x,brick_collider_size.y,0,0);
                    newBrick.setOffset(brick_collider_offset.x,brick_collider_offset.y);
                    newBrick.scaleX = brick_scales.x;
                    newBrick.scaleY = brick_scales.y;
                    numbreaks++;
                }
            }
            return bricks;
        }

        // Callback function for when the ball hits a brick
        function ball_brick_collision(ball, brick) {
            this.ball_brick.play();
            // If this brick is not already being destroyed
            if(brick.anims.currentAnim === null)
            {
                if (Math.floor(Math.random() * 100) < power_chance_out_of_100) {
                    var newpower = this.physics.add.sprite(brick.x, brick.y, 'power');
                    newpower.scaleX = power_scales.x;
                    newpower.scaleY = power_scales.y;
                    newpower.anims.play('power');
                    newpower.setImmovable(true); // Don't move when the ball hits the paddle
                    newpower.setVelocityY(power_speed);
                    this.physics.add.collider(paddle, newpower, paddle_power_collision, null, this);
                }  

                if(brick.texture.key == 'brick')
                {
                    brick.anims.play("brickBreak");
                    this.tweens.add({
                        targets: brick,
                        duration: brick_fade_time,
                        alpha: {start: 1, to: 0},
                        onComplete: function () {
                            brick.disableBody(true,true);
                        }
                    });
                }
                else
                {
                    brick.anims.play("iceBrickBreak");
                    this.tweens.add({
                        targets: brick,
                        duration: brick_fade_time,
                        alpha: {start: 1, to: 0},
                        onComplete: function () {
                            brick.disableBody(true,true);
                        }
                    });
                }
                numbreaks--;
                // Disable this brick's collision
                brick.body.checkCollision.none = true;
            }
            
            // TODO: Tally score or detect when the player wins or something like that
            if (numbreaks == 0) {
                winning = true;
                win.visible = true;
                ball.setVelocity(0, 0);
                ball.body.x = ball_initial_offset.x - 10;
                ball.body.y = ball_initial_offset.y - 10;
                paddle.x = paddle_initial_offset.x;
                paddle.y = paddle_initial_offset.y;
                paddle2.x = paddle2_initial_offset.x;
                paddle2.y = paddle2_initial_offset.y;
            }
        }

        function preload() {
            // Change these once we have the real assets
            this.load.image('paddle', 'assets/paddle.png');
            this.load.image('brick', 'assets/Brick Break/Brick Break1.png');
            this.load.image('brickBreak1', 'assets/Brick Break/Brick Break2.png');
            this.load.image('brickBreak2', 'assets/Brick Break/Brick Break3.png');
            this.load.image('iceBrick', 'assets/Ice Brick_Break/Ice Brick_Break1.png');
            this.load.image('iceBrickBreak1', 'assets/Ice Brick_Break/Ice Brick_Break2.png');
            this.load.image('iceBrickBreak2', 'assets/Ice Brick_Break/Ice Brick_Break3.png');
            this.load.image('ball', 'assets/ball.png');
            this.load.image('trap', 'assets/trap.png');
            this.load.image('power', 'assets/buff.png');
            this.load.image('background', 'assets/background.png');
            this.load.image('win', 'assets/win.png');
            this.load.image('lose', 'assets/lose.png');
            this.load.image('portal1', 'assets/blackhole1.png');
            this.load.image('portal2', 'assets/blackhole2.png');
            this.load.image('losinglife', 'assets/losinglife.png');
            this.load.image('lifeball', 'assets/lifeball.png');
            this.load.image('icewallleft', 'assets/icewallleft.png');
            this.load.image('icewallright', 'assets/icewallright.png');
            //this.load.multiatlas('snow', 'assets/Sheet2.json','assets');
            this.load.multiatlas('snow', 'assets/Sheets/Sheet.json', 'assets/Sheets');

            this.load.audio('ball_bounce', 'sound/ball_bounce.wav');
            this.load.audio('ball_brick', 'sound/ball_brick.wav');
            this.load.audio('buff', 'sound/buff.wav');
            this.load.audio('debuff', 'sound/debuff.wav');
            this.load.audio('losing_life', 'sound/losing_life.wav');
            this.load.audio('portal_sound', 'sound/portal_sound.wav');
        }

        function ball_paddle_collision(ball, paddle) {
            //set velocity based on the postion collision
            //ball.setVelocityX(600 * ((ball.body.x - paddle.x) / paddle.displayWidth))
            this.ball_bounce.play();
            //set velocity based on the speed of the paddle
            ball.setVelocityX(ball.body.velocity.x + paddle.body.velocity.x);
            // Since balls now have a max speed rather than max X velocity, adjust for loss of Y velocity
            if (Math.abs(ball.body.velocity.y) < cur_max_ball_speed * min_ball_y_speed_factor) {
                ball.setVelocityY(Math.sign(ball.body.velocity.y) * cur_max_ball_speed * min_ball_y_speed_factor);
            }
            // And finally make sure the ball never travels slower than the current max speed
            ball.setVelocity(ball.body.velocity.normalize().x * cur_max_ball_speed,
                             ball.body.velocity.normalize().y * cur_max_ball_speed);
        }

        function ball_trap_collision(ball, trap) {
            ball.disableBody(true, true);
            var index = balls.indexOf(ball);
            balls.splice(index, 1); // Remove this ball from the array

            if (balls.length === 0) {
                this.losing_life.play();
                if (life === 1) {
                    losing = true;
                    lose.visible = true;
                    ball.setVelocity(0, 0);
                    ball.body.x = ball_initial_offset.x - 10;
                    ball.body.y = ball_initial_offset.y - 10;
                    paddle.x = paddle_initial_offset.x;
                    paddle.y = paddle_initial_offset.y;
                    paddle2.x = paddle2_initial_offset.x;
                    paddle2.y = paddle2_initial_offset.y;
                    //Game.pause();
                    lifeText.setText('life: ' + 0);
                }

                else {
                    life--;
                    start = false;
                    eject = false;
                    portaled = false;
                    ball.setVelocity(0, 0);

                    paddle.x = paddle_initial_offset.x;
                    paddle.y = paddle_initial_offset.y;
                    paddle2.x = paddle2_initial_offset.x;
                    paddle2.y = paddle2_initial_offset.y;
                    //portal1.x = paddle_initial_offset.x;
                    //portal1.y = paddle_initial_offset.y;
                    //portal2.x = paddle2_initial_offset.x;
                    //portal2.y = paddle2_initial_offset.y;

                    reset_ball();
                    //ball.x = ball_initial_offset.x;
                    //ball.y = ball_initial_offset.y;
                    //ball.scaleX = ball_scales.x;
                    //ball.scaleY = ball_scales.y;

                    lifeText.setText('life: ' + life);
                    losinglife.visible = true;
                    timer = this.time.addEvent({ delay: 500, callback: reset_loseinglife, callbackScope: this });
                }
            }
        }

        function paddle_power_collision(paddle, power) {
            //I want to use a switch case to implement all the buffs, but I think we can just generate a random buff for this update.
            power.disableBody(true, true);

            switch (Math.floor(Math.random() * 6)) {
                case 0: // triple ball
                    this.buff.play();
                    spawn_two_balls(this);
                    break;
                case 1: // slower ball
                    this.buff.play();
                    slow_down_timers.push(max_slow_down_duration_in_ms);
                    // Slow down balls
                    cur_max_ball_speed *= ball_speed_slow_factor;
                    balls.forEach((val) => {
                        val.body.setMaxSpeed(cur_max_ball_speed);
                        // Don't let the ball's X velocity exceed a certain percentage of max speed
                        val.body.setMaxVelocity(cur_max_ball_speed*max_ball_x_speed_factor);
                    });
                    break;
                case 2: // shorter paddle
                    this.debuff.play();
                    paddle.setScale(paddle_scales.x * 0.5, paddle_scales.y * 1);
                    paddle2.setScale(paddle2_scales.x * 0.5, paddle2_scales.y * 1);
                    timer = this.time.addEvent({ delay: 5000, callback: reset_paddle, callbackScope: this });

                    break;
                case 3: // regenerate bricks
                    this.debuff.play();
                    var count = 0;
                    while (count < 7) {
                        var i = Math.floor(Math.random() * 10);
                        var j = Math.floor(Math.random() * 5);
                        var newBrick = bricks.create(first_brick_offset.x + i * brick_steps.x,
                            first_brick_offset.y + (j-1) * brick_steps.y, 'iceBrick');
                        newBrick.scaleX = ice_brick_scales.x;
                        newBrick.scaleY = ice_brick_scales.y;
                        newBrick.x += ice_brick_offset.x;
                        newBrick.y += ice_brick_offset.y;
                        newBrick.setSize(brick_collider_size.x*1.2, brick_collider_size.y*1.1);
                        newBrick.setOffset(ice_brick_offset.x+ 30,ice_brick_offset.y + 57);
                        this.physics.add.collider(ball, newBrick, ball_brick_collision, null, this);
                        numbreaks++;
                        count++;
                    }
                    break;
                case 4: // left snowstorm
                    // If there is already a left facing storm
                    this.debuff.play();
                    if(cur_snowstorm_direction === 'left')
                    {
                        // Increase its duration
                        cur_snowstorm_duration += snowstorm_storm_duration;
                    }
                    else if (cur_snowstorm_direction === 'right')
                    {   // If there is a snowstorm going right
                        // Reduce its duration
                        cur_snowstorm_duration -= snowstorm_storm_duration;

                    }
                    else // If there is no snowstorm
                    {
                        // Create one going let
                        tween_to_snowstorm('left',this);
                    }
                    break;
                case 5: // right snowstorm
                    // If is already a left facing storm
                    this.debuff.play();
                    if(cur_snowstorm_direction === 'left')
                    {
                        // Reduce its duration
                        cur_snowstorm_duration -= snowstorm_storm_duration;
                    }
                    else if (cur_snowstorm_direction === 'right')
                    {   // If there is already a snowstorm going right
                        // Increase its duration
                        cur_snowstorm_duration += snowstorm_storm_duration;

                    }
                    else // If there is no snowstorm
                    {
                        // Create one going right
                        tween_to_snowstorm('right',this);
                    }
                    break;
            }
        }

        function ball_portal_collision(ball, portal) {
            if (!portaled) {
                this.portal_sound.play();
                var tween1 = this.tweens.add({
                    targets: portal1,
                    alpha: {
                        from: 1, to: 0,
                        ease: 'Linear',
                        yoyo: true,
                    },
                    x: {
                        value: Math.floor(Math.random() * 500) + 40,
                        delay: 999,
                        ease: 'Stepped',
                        yoyo: false,
                    },
                    y: {
                        value: Math.floor(Math.random() * 50) + 250,
                        delay: 999,
                        ease: 'Stepped',
                        yoyo: false,
                    },
                    duration: 1000,
                    repeat: 0,
                });
                var tween2 = this.tweens.add({
                    targets: portal2,
                    alpha: {
                        from: 1, to: 0,
                        ease: 'Linear',
                        yoyo: true,
                    },
                    x: {
                        value: Math.floor(Math.random() * 500) + 40,
                        delay: 999,
                        ease: 'Stepped',
                        yoyo: false,
                    },
                    y: {
                        value: Math.floor(Math.random() * 50) + 490,
                        delay: 999,
                        ease: 'Stepped',
                        yoyo: false,
                    },
                    duration: 1000,
                    repeat: 0,
                });

                portaled = true;
                if (portal === portal1 || portal === portal2) {
                    if (portal === portal1) {
                        ball.body.x = portal2.body.x;
                        ball.body.y = portal2.body.y;
                        ball.setVelocityY(-200);
                    }
                    else {
                        ball.body.x = portal1.body.x;
                        ball.body.y = portal1.body.y;
                        ball.setVelocityY(200);
                    }
                }

                    //portal1.alpha = 0;
                    //portal2.alpha = 0;
                //else {
                //    if (portal === portal3) {
                //        ball.body.x = portal4.body.x;
                //        ball.body.y = portal4.body.y;
                //    }
                //    else {
                //        ball.body.x = portal3.body.x;
                //        ball.body.y = portal3.body.y;
                //    }
                //    portal3.body.x = Math.floor(Math.random() * 580);
                //    portal4.body.x = Math.floor(Math.random() * 580);
                //    portal3.body.y = Math.floor(Math.random() * 50) + 250;
                //    portal4.body.y = Math.floor(Math.random() * 50) + 490;
                //}
                timer = this.time.addEvent({ delay: 500, callback: reset_portal, callbackScope: this });
            }
        }

        function create() {

            this.anims.create({
                key: 'brick',
                frames: [{ key: 'power', frame: 0 }],
                frameRate: 20
            });

            this.anims.create({
                key: 'ice',
                frames: [{ key: 'power', frame: 1 }],
                frameRate: 20
            });

            this.anims.create({
                key: 'power',
                frames: [{ key: 'power', frame: 2 }],
                frameRate: 20
            });

            //this.anims.create({
            //    key: 'animatedPaddle',
            //    frames: this.anims.generateFrameNumbers('animatedPaddle', {start: 0, end: 1}),
            //    frameRate: 20,
            //    repeat: -1
            //})

            this.anims.create({
                key: 'brickBreak',
                frames: [
                    {key: 'brick'},
                    {key: 'brickBreak1'},
                    {key: 'brickBreak2'}
                ],
                frameRate: 10
            });

            this.anims.create({
                key: 'iceBrickBreak',
                frames: [
                    {key: 'iceBrick'},
                    {key: 'iceBrickBreak1'},
                    {key: 'iceBrickBreak2'}
                ],
                frameRate: 10
            });

            trap = this.physics.add.sprite(trap_initial_offset.x, trap_initial_offset.y, 'trap');
            trap.setCollideWorldBounds(true);
            trap.setImmovable(true);
            trap.scaleX = trap_scale.x;
            trap.scaleY = trap_scale.y;

            trap_top = this.physics.add.sprite(trap_top_initial_offset.x, trap_top_initial_offset.y, 'trap');
            trap_top.setCollideWorldBounds(true);
            trap_top.setImmovable(true);
            trap_top.scaleX = trap_top_scale.x;
            trap_top.scaleY = trap_top_scale.y;

            snowField = this.add.sprite(400, 400, 'snow');
            snowField.setScale(1, 1);
            var frameNames = this.anims.generateFrameNames('snow');
            this.anims.create({key: 'snow', frames: frameNames, frameRate: 15, repeat: -1});
            this.anims.create({key: 'snowstorm', frames: frameNames, frameRate: 45, repeat: -1});
            snowField.anims.play('snow');
            //snowField.scaleX = .5;
            //snowField.scaleY = .5;
            snowField.angle = 180;
            // TODO: Make a function that switches this to angle = 140 or 220 and plays snowstorm
            // TODO: Then apply physics to make the ball move to the right or left respectively

            background = this.physics.add.sprite(0, 0, 'background');
            background.setOrigin(0, 0);
            background.setScale(1, 1);
            background.alpha = 0.5;

            losinglife = this.physics.add.sprite(300, 400, 'losinglife');
            losinglife.alpha = 0.2; 
            losinglife.visible = false;
            //power = this.physics.add.sprite(0, 0, 'power');

            bricks = create_bricks(5, 10, this);

            paddle = this.physics.add.sprite(paddle_initial_offset.x, paddle_initial_offset.y, 'paddle');
            paddle.setCollideWorldBounds(true); // Don't allow movement outside the play area
            paddle.setImmovable(true); // Don't move when the ball hits the paddle
            paddle.scaleX = paddle_scales.x;
            paddle.scaleY = paddle_scales.y;
            //paddle.anims.play('animatedPaddle');
            //paddle.setSize(680,40,0,0);
            //paddle.setOffset(45,450);

            paddle2 = this.physics.add.sprite(paddle2_initial_offset.x, paddle2_initial_offset.y, 'paddle');
            paddle2.setCollideWorldBounds(true); // Don't allow movement outside the play area
            paddle2.setImmovable(true); // Don't move when the ball hits the paddle
            paddle2.scaleX = paddle2_scales.x;
            paddle2.scaleY = paddle2_scales.y;
            //paddle2.anims.play('animatedPaddle');
            //paddle2.setSize(680,40,0,0);
            //paddle2.setOffset(70,300);
            paddle2.angle = 180;

            portal1 = this.physics.add.sprite(portal1_initial_offset.x, portal1_initial_offset.y, 'portal1');
            portal1.setCollideWorldBounds(true); // Don't allow movement outside the play area
            portal1.setImmovable(true); // Don't move when the ball hits the paddle
            portal1.scaleX = portal_scales.x;
            portal1.scaleY = portal_scales.y;
            //portal1.setVelocity(200, 0);

            portal2 = this.physics.add.sprite(portal2_initial_offset.x, portal2_initial_offset.y, 'portal2');
            portal2.setCollideWorldBounds(true); // Don't allow movement outside the play area
            portal2.setImmovable(true); // Don't move when the ball hits the paddle
            portal2.scaleX = portal_scales.x;
            portal2.scaleY = portal_scales.y;
            //portal2.setVelocity(200, 0);

            icewallleft = this.physics.add.sprite(15, 400, 'icewallleft');
            icewallleft.setImmovable(true); // Don't move when the ball hits the paddle
            icewallleft.scaleX = 0.75
            icewallleft.scaleY = 1;

            icewallright = this.physics.add.sprite(585, 400, 'icewallright');
            icewallright.setImmovable(true); // Don't move when the ball hits the paddle
            icewallright.scaleX = 0.75
            icewallright.scaleY = 1;

            //portal3 = this.physics.add.sprite(portal3_initial_offset.x, portal3_initial_offset.y, 'portal');
            //portal3.setCollideWorldBounds(true); // Don't allow movement outside the play area
            //portal3.setImmovable(true); // Don't move when the ball hits the paddle
            //portal3.scaleX = portal_scales.x;
            //portal3.scaleY = portal_scales.y;

            //portal4 = this.physics.add.sprite(portal4_initial_offset.x, portal4_initial_offset.y, 'portal');
            //portal4.setCollideWorldBounds(true); // Don't allow movement outside the play area
            //portal4.setImmovable(true); // Don't move when the ball hits the paddle
            //portal4.scaleX = portal_scales.x;
            //portal4.scaleY = portal_scales.y;

            ball = this.physics.add.sprite(ball_initial_offset.x, ball_initial_offset.y, 'ball');
            ball.setCollideWorldBounds(true); // Make the ball bounce off the play area
            ball.setVelocity(0, 0);
            ball.setBounce(1); // Don't lose speed when bouncing
            ball.body.setMaxSpeed(max_ball_speed); // Never exceed max_ball_speed
            // Set a maximum X velocity to make sure the Y speed doesn't go too low
            ball.body.setMaxVelocity(cur_max_ball_speed*Math.sqrt(3)*0.5); 
            ball.scaleX = ball_scales.x;
            ball.scaleY = ball_scales.y;
            //ball.setSize(ball_collider_size.x,ball_collider_size.y);
            //ball.setOffset(ball_collider_offset.x, ball_collider_offset.y);
            balls.push(ball);

            lifeText = this.add.text(16, 16, 'life: ' + life, { fontSize: '32px', fill: '#fff' });
            win = this.physics.add.sprite(300, 300, 'win');
            lose = this.physics.add.sprite(300, 300, 'lose');
            win.visible = false;
            lose.visible = false; 

            this.physics.add.collider(ball, paddle, ball_paddle_collision, null, this);
            this.physics.add.collider(ball, paddle2, ball_paddle_collision, null, this);
            this.physics.add.collider(ball, bricks, ball_brick_collision, null, this);
            this.physics.add.collider(ball, trap, ball_trap_collision, null, this);
            this.physics.add.collider(ball, trap_top, ball_trap_collision, null, this);
            this.physics.add.collider(ball, portal1, ball_portal_collision, null, this);
            this.physics.add.collider(ball, portal2, ball_portal_collision, null, this);
            this.physics.add.collider(ball, icewallleft, ball_icewallleft_collision, null, this);
            this.physics.add.collider(ball, icewallright, ball_icewallright_collision, null, this);
            //this.physics.add.collider(ball, portal3, ball_portal_collision, null, this);
            //this.physics.add.collider(ball, portal4, ball_portal_collision, null, this);
            //this.physics.add.collider(paddle, power, paddle_power_collision, null, this);


            cursors = this.input.keyboard.createCursorKeys();

            this.ball_bounce = this.sound.add('ball_bounce');
            this.ball_brick = this.sound.add('ball_brick');
            this.buff = this.sound.add('buff');
            this.debuff = this.sound.add('debuff');
            this.losing_life = this.sound.add('losing_life');
            this.portal_sound = this.sound.add('portal_sound');
            //this.ball_bounce.play();
        }

        function update(time, deltaTime) {
            // Handle keyboard controls for moving the paddle
            if (cursors.left.isDown) {
                paddle.setVelocityX(-paddle_speed);
                paddle2.setVelocityX(-paddle2_speed);
                //portal1.setVelocityX(-paddle_speed);
                //portal2.setVelocityX(-paddle2_speed);
            }
            else if (cursors.right.isDown) {
                paddle.setVelocityX(paddle_speed);
                paddle2.setVelocityX(paddle2_speed);
                //portal1.setVelocityX(paddle_speed);
                //portal2.setVelocityX(paddle2_speed);
            }
            else {
                paddle.setVelocityX(0);
                paddle2.setVelocityX(0);
                //portal1.setVelocityX(0);
                //portal2.setVelocityX(0);
            }

            if (cursors.space.isDown)
            {
                if (start == false)
                    eject = true;
            }

            if (eject) {
                ball.setVelocity(200, 200);
                eject = false;
                start = true
            }
            if (!start) {
                ball.x = paddle.x;
            }

            // If there is a current snowstorm
            if(cur_snowstorm_direction != 'none' && cur_snowstorm_duration > 0)
            {
                // Count down its duration
                cur_snowstorm_duration -= deltaTime;
            }
            else if(cur_snowstorm_direction != 'none')
            {
                // If there is a storm and its over
                tween_from_snowstorm(cur_snowstorm_direction,this);
            }

            // Count down each slow down timer
            slow_down_timers.forEach((val, i) => {
                slow_down_timers[i] = val - deltaTime;
                if (val - deltaTime < 0) {
                    cur_max_ball_speed *= 1.0 / ball_speed_slow_factor; // Speed the balls back up
                    balls.forEach((val) => {
                        val.body.setMaxSpeed(cur_max_ball_speed);
                        val.setVelocity(val.body.velocity.normalize().x * cur_max_ball_speed,
                                        val.body.velocity.normalize().y * cur_max_ball_speed);
                        // Don't let the X velocity exceed a certain percentage of max speed
                        val.body.setMaxVelocity(cur_max_ball_speed*max_ball_x_speed_factor);
                    });
                    slow_down_timers.splice(i, 1);
                }
            });
        }


    </script>

</body>
</html>
