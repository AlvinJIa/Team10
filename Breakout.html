<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Breakout Clone</title>
    <script src="phaser.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>

<script type="text/javascript">

    var config = {
        type: Phaser.AUTO,
        width: 800,
        height: 600,
        physics: {
            default: 'arcade',
            arcade: {
                debug: false
            }
        },
        scene: {
            preload: preload,
            create: create,
            update: update
        }
    };

    var game = new Phaser.Game(config);

    var life = 3;
    var numbreaks = 0;
    var winning = false;
    var losing = false;
    var eject = false;
    var start = false;
    var paddle_speed = 200;
    var initial_ball_speed_vector = (100, 200);
    var max_ball_speed = Math.sqrt(Math.pow(100,2) + Math.pow(100,2)); // Initial speed magnitude
    var game_offset = { x: 0, y: 0 };
    var first_brick_offset = { x: game_offset.x + 50, y: game_offset.y + 50 };
    var brick_steps = { x: 50, y: 25 };
    var brick_scales = { x: .8, y: .3 };
    var paddle_initial_offset = { x: game_offset.x + 400, y: game_offset.y + 500 };
    var paddle_scales = { x: .5, y: .25 };
    var ball_initial_offset = {x: game_offset.x + 400, y: game_offset.y + 485 };
    var ball_scales = { x: .5, y: .5 };
    var trap_initial_offset = { x: 0, y: 600 };
    var trap_scale = {x : 2.5 , y : 1 };

    // Function for creating the grid of bricks
    function create_bricks(rows, cols, that)
    {
        var bricks = that.physics.add.staticGroup();

        for(i = 0; i < cols; i++)
        {
            for(j = 0; j < rows; j++)
            {
                var newBrick = bricks.create(first_brick_offset.x + i*brick_steps.x,
                              first_brick_offset.y + j*brick_steps.y,
                              'brick');
                newBrick.scaleX = brick_scales.x;
                newBrick.scaleY = brick_scales.y;
                numbreaks++;
            }
        }
        return bricks;
    }

    // Callback function for when the ball hits a brick
    function ball_brick_collision(ball, brick)
    {
        brick.disableBody(true,true);
        numbreaks--;
        // TODO: Tally score or detect when the player wins or something like that
        if(numbreaks == 0)
        {
          winning = true;
          winloseText.setText('You win!!!');
          ball.setVelocity(0,0);
          ball.body.x = ball_initial_offset.x-10;
          ball.body.y = ball_initial_offset.y-10;
          paddle.x = paddle_initial_offset.x;
          paddle.y = paddle_initial_offset.y;
        }
    }

    function preload ()
    {
        // Change these once we have the real assets
        this.load.image('paddle', 'assets/paddle_temp.png');
        this.load.image('brick', 'assets/brick_temp.png');
        this.load.image('ball', 'assets/ball_temp.png');
        this.load.image('trap','assets/trap.png')
    }

    function ball_paddle_collision(ball, paddle)
    {
        if(ball.x < paddle.x - paddle.displayWidth/6)
        {
            // The ball is hitting the left third of the paddle
            if(ball.body.velocity.x >= 0)
            {
                // The ball is moving to the right
                // So reverse the ball's x velocity, making it move to the left
                ball.setVelocityX(-ball.body.velocity.x);
            }
        }
        else if(ball.x > paddle.x + paddle.displayWidth/6)
        {
            // The ball is hitting the right third of the paddle
            if(ball.body.velocity.x <= 0)
            {
                // The ball is moving to the left
                // So reverse the ball's x velocity, making it move to the right
                ball.setVelocityX(-ball.body.velocity.x);
            }
        }
        else
        {
            // The ball is hitting the center third of the paddle
            // So just make the ball bounce, keeping its direction
        }
    }

    function ball_trap_collision(ball, trap)
    {
      if (life === 1){
        losing = true;
        winloseText.setText('You lose!!');
        ball.setVelocity(0,0);
        ball.body.x = ball_initial_offset.x-10;
        ball.body.y = ball_initial_offset.y-10;
        paddle.x = paddle_initial_offset.x;
        paddle.y = paddle_initial_offset.y;
        //Game.pause();
      }

      else
      {
        life--;
        start = false;
        eject = false;
        ball.setVelocity(0,0);

        paddle.x = paddle_initial_offset.x;
        paddle.y = paddle_initial_offset.y;

        ball.body.x = ball_initial_offset.x-10;
        ball.body.y = ball_initial_offset.y-10;
        //ball.x = ball_initial_offset.x;
        //ball.y = ball_initial_offset.y;
        //ball.scaleX = ball_scales.x;
        //ball.scaleY = ball_scales.y;

        lifeText.setText('life: ' + life);

      }
    }

    function create ()
    {
        var bricks = create_bricks(1,1,this);

        paddle = this.physics.add.sprite(paddle_initial_offset.x,paddle_initial_offset.y,'paddle');
        paddle.setCollideWorldBounds(true); // Don't allow movement outside the play area
        paddle.setImmovable(true); // Don't move when the ball hits the paddle
        paddle.scaleX = paddle_scales.x;
        paddle.scaleY = paddle_scales.y;

        ball = this.physics.add.sprite(ball_initial_offset.x,ball_initial_offset.y,'ball');
        ball.setCollideWorldBounds(true); // Make the ball bounce off the play area
        ball.setVelocity(0,0);
        ball.setBounce(1); // Don't lose speed when bouncing
        ball.setMaxVelocity(max_ball_speed); // Never exceed max_ball_speed
        ball.scaleX = ball_scales.x;
        ball.scaleY = ball_scales.y;

        trap = this.physics.add.sprite(trap_initial_offset.x,trap_initial_offset.y,'trap');
        trap.setCollideWorldBounds(true);
        trap.setImmovable(true);
        trap.scaleX = trap_scale.x;
        trap.scaleY = trap_scale.y;

        lifeText = this.add.text(16, 16, 'life: ' + life, { fontSize: '32px', fill: '#fff' });
        winloseText = this.add.text(230, 200, '', { fontSize: '60px', fill: '#fff' });

        this.physics.add.collider(ball, paddle, ball_paddle_collision, null, this);
        this.physics.add.collider(ball, bricks, ball_brick_collision, null, this);
        this.physics.add.collider(ball, trap, ball_trap_collision, null, this);

        // TODO: Add a collider on the bottom of the screen that makes the player lose a life

        cursors = this.input.keyboard.createCursorKeys();

    }

    function update ()
    {
        // Handle keyboard controls for moving the paddle
        if(cursors.left.isDown)
        {
            paddle.setVelocityX(-paddle_speed);
        }
        else if (cursors.right.isDown)
        {
            paddle.setVelocityX(paddle_speed);
        }
        else
        {
            paddle.setVelocityX(0);
        }

        if (cursors.down.isDown)
          if(start == false)
            eject = true;

        if (eject) {
          ball.setVelocity(200,200);
          eject = false;
          start = true
        }
        if(!start) {
          if(cursors.left.isDown)
          {
              ball.setVelocityX(-paddle_speed);
          }
          else if (cursors.right.isDown)
          {
              ball.setVelocityX(paddle_speed);
          }
          else
          {
              ball.setVelocityX(0);
          }
        }

        // TODO: If we want the ball to speed up after certain conditions,
        // TODO: check those conditions and update max_ball_speed and somehow
        // TODO: increase the ball's current speed

    }


</script>

</body>
</html>
