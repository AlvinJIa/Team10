<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Breakout Iteration 1 (Half Screen Bricks)</title>
    <script src="phaser.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>

<script type="text/javascript">

    var config = {
        type: Phaser.AUTO,
        width: 800,
        height: 600,
        physics: {
            default: 'arcade',
            arcade: {
                debug: false
            }
        },
        scene: {
            preload: preload,
            create: create,
            update: update
        }
    };

    var game = new Phaser.Game(config);

    var life = 3;
    var winning = false;
    var losing = false;
    var eject = false;
    var paddle_speed = 200;
    var initial_ball_speed_vector = (100, 200);
    var max_ball_speed = Math.sqrt(Math.pow(100,2) + Math.pow(100,2)); // Initial speed magnitude
    var game_offset = { x: 0, y: 0 };
    var first_brick_offset = { x: game_offset.x + 50, y: game_offset.y + 250 };
    var brick_steps = { x: 50, y: 25 };
    var brick_scales = { x: .8, y: .3 };
    var paddle_initial_offset = { x: game_offset.x + 400, y: game_offset.y + 500 };
    var paddle_scales = { x: .5, y: .25 };
    var ball_initial_offset = {x: game_offset.x + 400, y: game_offset.y + 400 };
    var ball_scales = { x: .5, y: .5 };
    //var trap_initial_offset = { x: 0, y: 0 };
    //var trap_area = { x: 800, y: 1 };

    // Function for creating the grid of bricks
    function create_bricks(rows, cols, that)
    {
        var bricks = that.physics.add.staticGroup();

        for(i = 0; i < cols; i++)
        {
            for(j = 0; j < rows; j++)
            {
                var newBrick = bricks.create(first_brick_offset.x + i*brick_steps.x,
                              first_brick_offset.y + j*brick_steps.y,
                              'brick');
                newBrick.scaleX = brick_scales.x;
                newBrick.scaleY = brick_scales.y;
            }
        }
        return bricks;
    }

    // Callback function for when the ball hits a brick
    function ball_brick_collision(ball, brick)
    {
        brick.disableBody(true,true);
        // TODO: Tally score or detect when the player wins or something like that
    }

    function preload ()
    {
        // Change these once we have the real assets
        this.load.image('paddle', 'assets/paddle_temp.png');
        this.load.image('brick', 'assets/brick_temp.png');
        this.load.image('ball', 'assets/ball_temp.png');
    }

    function ball_paddle_collision(ball, paddle)
    {
        if(ball.x < paddle.x - paddle.displayWidth/6)
        {
            // The ball is hitting the left third of the paddle
            if(ball.body.velocity.x >= 0)
            {
                // The ball is moving to the right
                // So reverse the ball's x velocity, making it move to the left
                ball.setVelocityX(-ball.body.velocity.x);
            }
        }
        else if(ball.x > paddle.x + paddle.displayWidth/6)
        {
            // The ball is hitting the right third of the paddle
            if(ball.body.velocity.x <= 0)
            {
                // The ball is moving to the left
                // So reverse the ball's x velocity, making it move to the right
                ball.setVelocityX(-ball.body.velocity.x);
            }
        }
        else
        {
            // The ball is hitting the center third of the paddle
            // So just make the ball bounce, keeping its direction
        }
    }

    function ball_trap_collision(ball, trap)
    {
      if (life == 1)
        losing = true;
      else
      {
        life--;
        paddle_initial_offset = { x: game_offset.x + 400, y: game_offset.y + 500 };
        ball_initial_offset = {x: game_offset.x + 400, y: game_offset.y + 400 };
      }
    }

    function create ()
    {
        var bricks = create_bricks(4,15,this);

        paddle = this.physics.add.sprite(paddle_initial_offset.x,paddle_initial_offset.y,'paddle');
        paddle.setCollideWorldBounds(true); // Don't allow movement outside the play area
        paddle.setImmovable(true); // Don't move when the ball hits the paddle
        paddle.scaleX = paddle_scales.x;
        paddle.scaleY = paddle_scales.y;

        ball = this.physics.add.sprite(ball_initial_offset.x,ball_initial_offset.y,'ball');
        ball.setCollideWorldBounds(true); // Make the ball bounce off the play area
        ball.setVelocity(0,0);
        ball.setBounce(1); // Don't lose speed when bouncing
        ball.setMaxVelocity(max_ball_speed); // Never exceed max_ball_speed
        ball.scaleX = ball_scales.x;
        ball.scaleY = ball_scales.y;

        trap = this.physics.add.sprite()

        this.physics.add.collider(ball, paddle, ball_paddle_collision, null, this);
        this.physics.add.collider(ball, bricks, ball_brick_collision, null, this);
        this.physics.add.collider(ball, trap, ball_trap_collision, null, this);

        // TODO: Add a collider on the bottom of the screen that makes the player lose a life

        cursors = this.input.keyboard.createCursorKeys();

    }

    function update ()
    {
        // Handle keyboard controls for moving the paddle
        if(cursors.left.isDown)
        {
            paddle.setVelocityX(-paddle_speed);
        }
        else if (cursors.right.isDown)
        {
            paddle.setVelocityX(paddle_speed);
        }
        else
        {
            paddle.setVelocityX(0);
        }

        if (cursors.down.isDown) {
          eject = true;
        }

        if (eject) {
          ball.setVelocity(100,200);
          eject = false;
        }

        // TODO: If we want the ball to speed up after certain conditions,
        // TODO: check those conditions and update max_ball_speed and somehow
        // TODO: increase the ball's current speed

    }


</script>

</body>
</html>
