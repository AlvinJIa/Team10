

<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Breakout Iteration 5 (Snowstorm Debuffs)</title>
    <script src="phaser.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>

    <script type="text/javascript">

        var config = {
            type: Phaser.AUTO,
            width: 600,
            height: 800,
            physics: {
                default: 'arcade',
                arcade: {
                    debug: false
                }
            },
            scene: {
                preload: preload,
                create: create,
                update: update
            }
        };

        var game = new Phaser.Game(config);

        var life = 3;
        var numbreaks = 0;
        var winning = false;
        var losing = false;
        var eject = false;
        var start = false;
        var paddle_speed = 300;
        var paddle2_speed = 300;
        var initial_ball_speed_vector = (100, 200);
        var max_ball_speed = 250;
        var cur_max_ball_speed = max_ball_speed;
        var min_ball_y_speed_factor = 1.0/2.0;
        var max_ball_x_speed_factor = Math.sqrt(3)*0.5
        var game_offset = { x: 0, y: 0 };
        var first_brick_offset = { x: game_offset.x + 95, y: game_offset.y + 350 };
        var brick_steps = { x: 46, y: 25 };
        var brick_scales = { x: 1.5, y: 1 };
        var paddle_initial_offset = { x: game_offset.x + 300, y: game_offset.y + 700 };
        var paddle_scales = { x: .5, y: .25 };
        var paddle2_initial_offset = { x: game_offset.x + 300, y: game_offset.y + 100 };
        var paddle2_scales = { x: .5, y: .25 };
        var ball_initial_offset = { x: game_offset.x + 300, y: game_offset.y + 685 };
        var ball_scales = { x: .5, y: .5 };
        var trap_initial_offset = { x: 0, y: 800 };
        var trap_scale = { x: 2.5, y: 1 };
        var trap_top_initial_offset = { x: 0, y: 0 };
        var trap_top_scale = { x: 2.5, y: 1 };
        var power_speed = 200;
        var power_scale = { x: 1, y: 1 };
        var power_chance_out_of_100 = 25;
        var max_slow_down_duration_in_ms = 10000; // 10 seconds
        var ball_speed_slow_factor = 1.0 / 2.0;
        var slow_down_timers = [];
        var balls = [];
        var snowstorm_tween_duration = 000;
        var snowstorm_storm_duration = 10000;
        var cur_snowstorm_duration = 0;
        var snow_ms_per_frame = 200/3.0; // 15 frames per second
        var snowstorm_ms_per_frame = 200/9.0; // 45 frames per second
        var snowstorm_ball_accelerations = {x:100, y:0};
        var non_snowstorm_ball_accelerations = {x:0, y:0};
        var cur_ball_accelerations = {x:non_snowstorm_ball_accelerations.x, 
                                      y:non_snowstorm_ball_accelerations.y};
        var cur_snowstorm_direction = 'none';

        function reset_ball() {
            ball.enableBody(true,
                ball_initial_offset.x,
                ball_initial_offset.y,
                true,
                true);
            balls.push(ball);
            // TODO: Clear all the slow downs and other power ups
        }

        function reset_paddle() {
            paddle.setScale(0.5, 0.25);
            paddle2.setScale(0.5, 0.25);
        }

        function spawn_two_balls(that) {
            var newBall1 = that.physics.add.sprite(paddle.x - paddle.displayWidth / 3,
                ball_initial_offset.y, 'ball');
            newBall1.setCollideWorldBounds(true);
            newBall1.setVelocity(-200, -200); // Up and to the left
            newBall1.setBounce(1);
            newBall1.body.setMaxSpeed(cur_max_ball_speed);
            newBall1.scaleX = ball_scales.x;
            newBall1.scaleY = ball_scales.y;
            balls.push(newBall1);
            newBall1.body.acceleration.x = cur_ball_accelerations.x;
            newBall1.body.acceleration.y = cur_ball_accelerations.y;
            that.physics.add.collider(newBall1, paddle, ball_paddle_collision, null, that);
            that.physics.add.collider(newBall1, paddle2, ball_paddle_collision, null, that);
            that.physics.add.collider(newBall1, bricks, ball_brick_collision, null, that);
            that.physics.add.collider(newBall1, trap, ball_trap_collision, null, that);
            that.physics.add.collider(newBall1, trap_top, ball_trap_collision, null, that);


            var newBall2 = that.physics.add.sprite(paddle.x + paddle.displayWidth / 3,
                ball_initial_offset.y, 'ball');
            newBall2.setCollideWorldBounds(true);
            newBall2.setVelocity(200, -200); // Up and to the right
            newBall2.setBounce(1);
            newBall2.body.setMaxSpeed(cur_max_ball_speed);
            newBall2.scaleX = ball_scales.x;
            newBall2.scaleY = ball_scales.y;
            balls.push(newBall2);
            newBall2.body.acceleration.x = cur_ball_accelerations.x;
            newBall2.body.acceleration.y = cur_ball_accelerations.y;
            that.physics.add.collider(newBall2, paddle, ball_paddle_collision, null, that);
            that.physics.add.collider(newBall2, paddle2, ball_paddle_collision, null, that);
            that.physics.add.collider(newBall2, bricks, ball_brick_collision, null, that);
            that.physics.add.collider(newBall2, trap, ball_trap_collision, null, that);
            that.physics.add.collider(newBall2, trap_top, ball_trap_collision, null, that);
        }

        function tween_from_snowstorm(startDirection, that)
        {
            if(startDirection === 'none' || startDirection != cur_snowstorm_direction)
            {
                return; // Do nothing if there is no storm active or if the other storm is active
            }

            cur_snowstorm_direction = 'none';
            cur_snowstorm_duration = 0;

            // Tween the framerate of the storm down to nonsnowstorm levels
            that.tweens.add({
                targets: snowField.anims,
                duration: snowstorm_tween_duration,
                msPerFrame: {start: snowstorm_ms_per_frame, to: snow_ms_per_frame},
            });


            // Tween the acceleration of the balls
            that.tweens.add({
                targets: cur_ball_accelerations,
                duration: snowstorm_tween_duration,
                x: {start: cur_ball_accelerations.x, to: non_snowstorm_ball_accelerations.x},
                y: {start: cur_ball_accelerations.y, to: non_snowstorm_ball_accelerations.y},
                onUpdate: function () {
                    balls.forEach((val) => {
                        val.body.acceleration.x = cur_ball_accelerations.x;
                        val.body.acceleration.y = cur_ball_accelerations.y;
                    });
                }
            });

            if(startDirection === 'left')
            {
                // Tween the direction of the snow back to normal
                that.tweens.add({
                    targets: snowField,
                    duration: snowstorm_tween_duration,
                    angle: {start: -140, to: -180},
                    onComplete: function () {
                        console.log("Snowstorm pointing left has subsided");
                    },
                });
            }
            else
            {
                // Tween the direction of the snow back to normal
                that.tweens.add({
                    targets: snowField,
                    duration: snowstorm_tween_duration,
                    angle: {start: 140, to: 180},
                    onComplete: function () {
                        console.log("Snowstorm pointing right has subsided");
                    },
                });
            }


        }

        function tween_to_snowstorm(direction, that)
        {
            if(direction === 'none' || direction === cur_snowstorm_direction)
            {
                return; // Nothing to do if a direction wasn't specified or is already going
            }

            cur_snowstorm_direction = direction;
            cur_snowstorm_duration += snowstorm_storm_duration + snowstorm_tween_duration;

            // Tween the framerate of the storm up to snowstorm levels
            that.tweens.add({
                targets: snowField.anims,
                duration: snowstorm_tween_duration,
                msPerFrame: {start: snow_ms_per_frame, to: snowstorm_ms_per_frame},
            });

            if(direction === 'left')
            {
                // Tween the direction of the storm to the left
                that.tweens.add({
                    targets: snowField,
                    duration: snowstorm_tween_duration,
                    angle: {start: -180, to: -140},
                    onComplete: function () {
                        console.log("Snowstorm is pointing left");
                    },
                });

                // Tween the acceleration of the balls
                that.tweens.add({
                    targets:cur_ball_accelerations,
                    duration: snowstorm_tween_duration,
                    x: {start: non_snowstorm_ball_accelerations.x, to: -snowstorm_ball_accelerations.x},
                    y: {start: non_snowstorm_ball_accelerations.y, to: snowstorm_ball_accelerations.y},
                    onUpdate: function () {
                        balls.forEach((val) => {
                            val.body.acceleration.x = cur_ball_accelerations.x;
                            val.body.acceleration.y = cur_ball_accelerations.y;
                        });
                    }
                });
            }
            else
            {
                // Tween the direction of the storm to the right
                that.tweens.add({
                    targets: snowField,
                    duration: snowstorm_tween_duration,
                    angle: {start: 179, to: 140},
                    onComplete: function () {
                        console.log("Snowstorm is pointing right");
                    },
                });

                // Tween the acceleration of the balls
                that.tweens.add({
                    targets:cur_ball_accelerations,
                    duration: snowstorm_tween_duration,
                    x: {start: non_snowstorm_ball_accelerations.x, to: snowstorm_ball_accelerations.x},
                    y: {start: non_snowstorm_ball_accelerations.y, to: snowstorm_ball_accelerations.y},
                    onUpdate: function () {
                        balls.forEach((val) => {
                            val.body.acceleration.x = cur_ball_accelerations.x;
                            val.body.acceleration.y = cur_ball_accelerations.y;
                        });
                    }
                });
            }
        }

        // Function for creating the grid of bricks
        function create_bricks(rows, cols, that) {
            var bricks = that.physics.add.staticGroup();

            for (i = 0; i < cols; i++) {
                for (j = 0; j < rows; j++) {
                    var newBrick = bricks.create(first_brick_offset.x + i * brick_steps.x,
                        first_brick_offset.y + j * brick_steps.y,
                        'power');
                    newBrick.anims.play('brick');
                    newBrick.scaleX = brick_scales.x;
                    newBrick.scaleY = brick_scales.y;
                    numbreaks++;
                }
            }
            return bricks;
        }

        // Callback function for when the ball hits a brick
        function ball_brick_collision(ball, brick) {
            if (Math.floor(Math.random() * 100) < power_chance_out_of_100) {
                var newpower = this.physics.add.sprite(brick.body.x, brick.body.y, 'power');
                newpower.scaleX = brick_scales.x;
                newpower.scaleY = brick_scales.y;
                newpower.anims.play('power');
                newpower.setImmovable(true); // Don't move when the ball hits the paddle
                newpower.setVelocityY(power_speed);
                this.physics.add.collider(paddle, newpower, paddle_power_collision, null, this);
            }

            brick.disableBody(true, true);
            numbreaks--;
            // TODO: Tally score or detect when the player wins or something like that
            if (numbreaks == 0) {
                winning = true;
                win.visible = true;
                ball.setVelocity(0, 0);
                ball.body.x = ball_initial_offset.x - 10;
                ball.body.y = ball_initial_offset.y - 10;
                paddle.x = paddle_initial_offset.x;
                paddle.y = paddle_initial_offset.y;
                paddle2.x = paddle2_initial_offset.x;
                paddle2.y = paddle2_initial_offset.y;
            }
        }

        function preload() {
            // Change these once we have the real assets
            this.load.image('paddle', 'assets/paddle_temp.png');
            this.load.image('brick', 'assets/brick_temp.png');
            this.load.image('ball', 'assets/ball_temp.png');
            this.load.image('trap', 'assets/trap.png');
            this.load.spritesheet('power', 'assets/bricks01.png', { frameWidth: 34, frameHeight: 20 });
            this.load.image('background', 'assets/background_transparent_temp.png');
            //this.load.spritesheet('snow', 'assets/snow_sheet2.png', { frameWidth: 1600, 
            //                                                          frameHeight: 1600 });
            this.load.image('win', 'assets/win.png');
            this.load.image('lose', 'assets/lose.png');
            //this.load.multiatlas('snow', 'assets/Sheet2.json','assets');
            this.load.multiatlas('snow', 'assets/Sheets/Sheet.json', 'assets/Sheets')
        }

        function ball_paddle_collision(ball, paddle) {
            //set velocity based on the postion collision
            //ball.setVelocityX(600 * ((ball.body.x - paddle.x) / paddle.displayWidth))

            //set velocity based on the speed of the paddle
            ball.setVelocityX(ball.body.velocity.x + paddle.body.velocity.x);
            // Since balls now have a max speed rather than max X velocity, adjust for loss of Y velocity
            if (Math.abs(ball.body.velocity.y) < cur_max_ball_speed * min_ball_y_speed_factor) {
                ball.setVelocityY(Math.sign(ball.body.velocity.y) * cur_max_ball_speed * min_ball_y_speed_factor);
            }
            // And finally make sure the ball never travels slower than the current max speed
            ball.setVelocity(ball.body.velocity.normalize().x * cur_max_ball_speed,
                             ball.body.velocity.normalize().y * cur_max_ball_speed);
        }

        function ball_trap_collision(ball, trap) {
            ball.disableBody(true, true);
            var index = balls.indexOf(ball);
            balls.splice(index, 1); // Remove this ball from the array

            if (balls.length === 0) {
                if (life === 1) {
                    losing = true;
                    lose.visible = true;
                    ball.setVelocity(0, 0);
                    ball.body.x = ball_initial_offset.x - 10;
                    ball.body.y = ball_initial_offset.y - 10;
                    paddle.x = paddle_initial_offset.x;
                    paddle.y = paddle_initial_offset.y;
                    paddle2.x = paddle2_initial_offset.x;
                    paddle2.y = paddle2_initial_offset.y;
                    //Game.pause();
                    lifeText.setText('life: ' + 0);
                }

                else {
                    life--;
                    start = false;
                    eject = false;
                    ball.setVelocity(0, 0);

                    paddle.x = paddle_initial_offset.x;
                    paddle.y = paddle_initial_offset.y;
                    paddle2.x = paddle2_initial_offset.x;
                    paddle2.y = paddle2_initial_offset.y;

                    reset_ball();
                    //ball.x = ball_initial_offset.x;
                    //ball.y = ball_initial_offset.y;
                    //ball.scaleX = ball_scales.x;
                    //ball.scaleY = ball_scales.y;

                    lifeText.setText('life: ' + life);

                }
            }
        }

        function paddle_power_collision(paddle, power) {
            //I want to use a switch case to implement all the buffs, but I think we can just generate a random buff for this update.
            power.disableBody(true, true);

            switch (Math.floor(Math.random() * 6)) {
                case 0: // triple ball
                    spawn_two_balls(this);
                    break;
                case 1: // slower ball
                    slow_down_timers.push(max_slow_down_duration_in_ms);
                    // Slow down balls
                    cur_max_ball_speed *= ball_speed_slow_factor;
                    balls.forEach((val) => {
                        val.body.setMaxSpeed(cur_max_ball_speed);
                        // Don't let the ball's X velocity exceed a certain percentage of max speed
                        val.body.setMaxVelocity(cur_max_ball_speed*max_ball_x_speed_factor);
                    });
                    break;
                case 2: // shorter paddle
                    paddle.setScale(0.25, 0.25);
                    paddle2.setScale(0.25, 0.25);
                    timer = this.time.addEvent({ delay: 5000, callback: reset_paddle, callbackScope: this });

                    break;
                case 3: // regenerate bricks
                    var count = 0;
                    while (count < 7) {
                        var i = Math.floor(Math.random() * 10);
                        var j = Math.floor(Math.random() * 7);
                        var newBrick = bricks.create(first_brick_offset.x + i * brick_steps.x,
                            first_brick_offset.y + (j-1) * brick_steps.y, 'power');
                        newBrick.anims.play('brick1');
                        newBrick.scaleX = brick_scales.x;
                        newBrick.scaleY = brick_scales.y;
                        this.physics.add.collider(ball, newBrick, ball_brick_collision, null, this);
                        numbreaks++;
                        count++;
                    }
                    break;
                case 4: // left snowstorm
                    // If there is already a left facing storm
                    if(cur_snowstorm_direction === 'left')
                    {
                        // Increase its duration
                        cur_snowstorm_duration += snowstorm_storm_duration;
                    }
                    else if (cur_snowstorm_direction === 'right')
                    {   // If there is a snowstorm going right
                        // Reduce its duration
                        cur_snowstorm_duration -= snowstorm_storm_duration;

                    }
                    else // If there is no snowstorm
                    {
                        // Create one going let
                        tween_to_snowstorm('left',this);
                    }
                    break;
                case 5: // right snowstorm
                    // If is already a left facing storm
                    if(cur_snowstorm_direction === 'left')
                    {
                        // Reduce its duration
                        cur_snowstorm_duration -= snowstorm_storm_duration;
                    }
                    else if (cur_snowstorm_direction === 'right')
                    {   // If there is already a snowstorm going right
                        // Increase its duration
                        cur_snowstorm_duration += snowstorm_storm_duration;

                    }
                    else // If there is no snowstorm
                    {
                        // Create one going right
                        tween_to_snowstorm('right',this);
                    }
                    break;
            }
        }

        function create() {

            this.anims.create({
                key: 'brick',
                frames: [{ key: 'power', frame: 0 }],
                frameRate: 20
            });

            this.anims.create({
                key: 'brick1',
                frames: [{ key: 'power', frame: 1 }],
                frameRate: 20
            });

            this.anims.create({
                key: 'power',
                frames: [{ key: 'power', frame: 2 }],
                frameRate: 20
            });

            // this.anims.create({
            //     key: 'snow',
            //     frames: this.anims.generateFrameNumbers('snow', { start: 0, end: 161 }),
            //     frameRate: 5,
            //     repeat: -1
            // });

            trap = this.physics.add.sprite(trap_initial_offset.x, trap_initial_offset.y, 'trap');
            trap.setCollideWorldBounds(true);
            trap.setImmovable(true);
            trap.scaleX = trap_scale.x;
            trap.scaleY = trap_scale.y;

            trap_top = this.physics.add.sprite(trap_top_initial_offset.x, trap_top_initial_offset.y, 'trap');
            trap_top.setCollideWorldBounds(true);
            trap_top.setImmovable(true);
            trap_top.scaleX = trap_top_scale.x;
            trap_top.scaleY = trap_top_scale.y;

            

            snowField = this.add.sprite(400, 400, 'snow');
            snowField.setScale(1, 1);
            var frameNames = this.anims.generateFrameNames('snow');
            this.anims.create({key: 'snow', frames: frameNames, frameRate: 15, repeat: -1});
            this.anims.create({key: 'snowstorm', frames: frameNames, frameRate: 45, repeat: -1});
            snowField.anims.play('snow');
            //snowField.scaleX = .5;
            //snowField.scaleY = .5;
            snowField.angle = 180;
            // TODO: Make a function that switches this to angle = 140 or 220 and plays snowstorm
            // TODO: Then apply physics to make the ball move to the right or left respectively

            background = this.physics.add.sprite(0, 0, 'background');
            background.setOrigin(0, 0);
            background.setScale(1.36, 1.48);

            //power = this.physics.add.sprite(0, 0, 'power');

            bricks = create_bricks(5, 10, this);

            paddle = this.physics.add.sprite(paddle_initial_offset.x, paddle_initial_offset.y, 'paddle');
            paddle.setCollideWorldBounds(true); // Don't allow movement outside the play area
            paddle.setImmovable(true); // Don't move when the ball hits the paddle
            paddle.scaleX = paddle_scales.x;
            paddle.scaleY = paddle_scales.y;

            paddle2 = this.physics.add.sprite(paddle2_initial_offset.x, paddle2_initial_offset.y, 'paddle');
            paddle2.setCollideWorldBounds(true); // Don't allow movement outside the play area
            paddle2.setImmovable(true); // Don't move when the ball hits the paddle
            paddle2.scaleX = paddle2_scales.x;
            paddle2.scaleY = paddle2_scales.y;

            ball = this.physics.add.sprite(ball_initial_offset.x, ball_initial_offset.y, 'ball');
            ball.setCollideWorldBounds(true); // Make the ball bounce off the play area
            ball.setVelocity(0, 0);
            ball.setBounce(1); // Don't lose speed when bouncing
            ball.body.setMaxSpeed(max_ball_speed); // Never exceed max_ball_speed
            // Set a maximum X velocity to make sure the Y speed doesn't go too low
            ball.body.setMaxVelocity(cur_max_ball_speed*Math.sqrt(3)*0.5); 
            ball.scaleX = ball_scales.x;
            ball.scaleY = ball_scales.y;
            balls.push(ball);

            lifeText = this.add.text(16, 16, 'life: ' + life, { fontSize: '32px', fill: '#fff' });
            win = this.physics.add.sprite(300, 300, 'win');
            lose = this.physics.add.sprite(300, 300, 'lose');
            win.visible = false;
            lose.visible = false;

            this.physics.add.collider(ball, paddle, ball_paddle_collision, null, this);
            this.physics.add.collider(ball, paddle2, ball_paddle_collision, null, this);
            this.physics.add.collider(ball, bricks, ball_brick_collision, null, this);
            this.physics.add.collider(ball, trap, ball_trap_collision, null, this);
            this.physics.add.collider(ball, trap_top, ball_trap_collision, null, this);
            //this.physics.add.collider(paddle, power, paddle_power_collision, null, this);


            cursors = this.input.keyboard.createCursorKeys();

            

        }

        function update(time, deltaTime) {
            // Handle keyboard controls for moving the paddle
            if (cursors.left.isDown) {
                paddle.setVelocityX(-paddle_speed);
                paddle2.setVelocityX(-paddle2_speed);
            }
            else if (cursors.right.isDown) {
                paddle.setVelocityX(paddle_speed);
                paddle2.setVelocityX(paddle2_speed);
            }
            else {
                paddle.setVelocityX(0);
                paddle2.setVelocityX(0);
            }

            if (cursors.space.isDown)
            {
                if (start == false)
                    eject = true;
            }

            if (eject) {
                ball.setVelocity(200, 200);
                eject = false;
                start = true
            }
            if (!start) {
                ball.x = paddle.x;
            }

            // If there is a current snowstorm
            if(cur_snowstorm_direction != 'none' && cur_snowstorm_duration > 0)
            {
                // Count down its duration
                cur_snowstorm_duration -= deltaTime;
            }
            else if(cur_snowstorm_direction != 'none')
            {
                // If there is a storm and its over
                tween_from_snowstorm(cur_snowstorm_direction,this);
            }

            // Count down each slow down timer
            slow_down_timers.forEach((val, i) => {
                slow_down_timers[i] = val - deltaTime;
                if (val - deltaTime < 0) {
                    cur_max_ball_speed *= 1.0 / ball_speed_slow_factor; // Speed the balls back up
                    balls.forEach((val) => {
                        val.body.setMaxSpeed(cur_max_ball_speed);
                        val.setVelocity(val.body.velocity.normalize().x * cur_max_ball_speed,
                                        val.body.velocity.normalize().y * cur_max_ball_speed);
                        // Don't let the X velocity exceed a certain percentage of max speed
                        val.body.setMaxVelocity(cur_max_ball_speed*max_ball_x_speed_factor);
                    });
                    slow_down_timers.splice(i, 1);
                }
            });
        }


    </script>

</body>
</html>
